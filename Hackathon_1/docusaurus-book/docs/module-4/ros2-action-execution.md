---
sidebar_position: 6
---

# ROS 2 Action Execution

## Overview

The ROS 2 action execution component is responsible for translating high-level task plans generated by the LLM planner into concrete robot behaviors. This system uses ROS 2's action interface to execute long-running tasks like navigation and manipulation while providing feedback on execution status.

## ROS 2 Actions vs. Services vs. Topics

In the VLA system, we use different ROS 2 communication patterns for different purposes:

- **Actions**: For long-running tasks with feedback (navigation, manipulation)
- **Services**: For one-off requests (object detection, planning queries)
- **Topics**: For continuous data streams (sensor data, status updates)

Actions are particularly important for the VLA system because they provide:
- Execution feedback during long-running operations
- Preemption capability for interrupting tasks
- Result reporting upon completion

## System Architecture

The action execution system connects task plans to ROS 2 actions:

```
Task Plan → Action Client → ROS 2 Action Server → Robot Hardware/Simulation
```

### Action Client Management

The system manages multiple concurrent action clients:

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose
from control_msgs.action import FollowJointTrajectory
from std_msgs.msg import String
from typing import Dict, Any, Optional
import asyncio
import uuid

class ActionExecutor(Node):
    def __init__(self):
        super().__init__('vla_action_executor')

        # Action clients for different robot capabilities
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.manipulation_client = ActionClient(self, FollowJointTrajectory, 'manipulation_controller')

        # Track active actions
        self.active_actions: Dict[str, Any] = {}

    async def execute_navigation_task(self, task_params: Dict[str, Any]) -> str:
        """Execute a navigation task using ROS 2 navigation action."""
        # Create navigation goal
        goal = NavigateToPose.Goal()
        goal.pose.header.frame_id = 'map'
        goal.pose.pose.position.x = task_params.get('x', 0.0)
        goal.pose.pose.position.y = task_params.get('y', 0.0)
        goal.pose.pose.orientation.w = 1.0  # Simplified orientation

        # Wait for action server
        self.nav_client.wait_for_server()

        # Send goal
        goal_handle = await self.nav_client.send_goal_async(goal)

        # Track the action
        action_id = str(uuid.uuid4())
        self.active_actions[action_id] = {
            'type': 'navigation',
            'goal_handle': goal_handle,
            'start_time': self.get_clock().now()
        }

        return action_id

    async def execute_manipulation_task(self, task_params: Dict[str, Any]) -> str:
        """Execute a manipulation task using ROS 2 manipulation action."""
        # Create manipulation goal
        goal = FollowJointTrajectory.Goal()
        goal.trajectory.joint_names = task_params.get('joint_names', [])
        goal.trajectory.points = task_params.get('trajectory_points', [])

        # Wait for action server
        self.manipulation_client.wait_for_server()

        # Send goal
        goal_handle = await self.manipulation_client.send_goal_async(goal)

        # Track the action
        action_id = str(uuid.uuid4())
        self.active_actions[action_id] = {
            'type': 'manipulation',
            'goal_handle': goal_handle,
            'start_time': self.get_clock().now()
        }

        return action_id

    async def get_action_status(self, action_id: str) -> Dict[str, Any]:
        """Get the status of an active action."""
        if action_id not in self.active_actions:
            return {'status': 'unknown', 'error': 'Action ID not found'}

        action_info = self.active_actions[action_id]
        goal_handle = action_info['goal_handle']

        # Get result status
        if goal_handle.status == goal_handle.STATUS_ACCEPTED:
            status = 'pending'
        elif goal_handle.status == goal_handle.STATUS_EXECUTING:
            status = 'executing'
        elif goal_handle.status == goal_handle.STATUS_SUCCEEDED:
            status = 'completed'
        elif goal_handle.status == goal_handle.STATUS_CANCELED:
            status = 'cancelled'
        elif goal_handle.status == goal_handle.STATUS_ABORTED:
            status = 'failed'
        else:
            status = 'unknown'

        return {
            'action_id': action_id,
            'status': status,
            'type': action_info['type'],
            'elapsed_time': (self.get_clock().now() - action_info['start_time']).nanoseconds / 1e9
        }
```

## Action Sequence Management

The system manages sequences of actions from task plans:

```python
from enum import Enum
from typing import List, Dict, Any
import asyncio

class ActionSequenceStatus(str, Enum):
    PENDING = "pending"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    INTERRUPTED = "interrupted"

class ActionSequenceExecutor:
    def __init__(self, action_executor: ActionExecutor):
        self.action_executor = action_executor
        self.sequences: Dict[str, Dict[str, Any]] = {}

    async def execute_action_sequence(self, plan_id: str, actions: List[Dict[str, Any]]) -> str:
        """Execute a sequence of actions from a task plan."""
        sequence_id = str(uuid.uuid4())

        sequence_info = {
            'plan_id': plan_id,
            'actions': actions,
            'status': ActionSequenceStatus.PENDING,
            'current_action_index': 0,
            'execution_log': [],
            'start_time': self.action_executor.get_clock().now()
        }

        self.sequences[sequence_id] = sequence_info

        # Update status to executing
        sequence_info['status'] = ActionSequenceStatus.EXECUTING

        try:
            await self._execute_sequence(sequence_id)
            sequence_info['status'] = ActionSequenceStatus.COMPLETED
        except Exception as e:
            sequence_info['status'] = ActionSequenceStatus.FAILED
            sequence_info['error'] = str(e)

        return sequence_id

    async def _execute_sequence(self, sequence_id: str):
        """Execute actions in sequence, handling dependencies and failures."""
        sequence_info = self.sequences[sequence_id]
        actions = sequence_info['actions']

        for i, action in enumerate(actions):
            sequence_info['current_action_index'] = i

            # Execute the action
            action_result = await self._execute_single_action(action)

            # Log the result
            sequence_info['execution_log'].append({
                'action_index': i,
                'action_type': action['type'],
                'result': action_result,
                'timestamp': self.action_executor.get_clock().now().isoformat()
            })

            # Check if action succeeded
            if not action_result.get('success', False):
                raise Exception(f"Action {i} failed: {action_result.get('error')}")

    async def _execute_single_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a single action based on its type."""
        try:
            if action['type'] == 'navigation':
                action_id = await self.action_executor.execute_navigation_task(action['parameters'])

                # Wait for completion with timeout
                status = await self._wait_for_action_completion(action_id, action.get('timeout', 30.0))

                return {
                    'success': status['status'] == 'completed',
                    'action_id': action_id,
                    'final_status': status['status']
                }

            elif action['type'] == 'manipulation':
                action_id = await self.action_executor.execute_manipulation_task(action['parameters'])

                # Wait for completion with timeout
                status = await self._wait_for_action_completion(action_id, action.get('timeout', 30.0))

                return {
                    'success': status['status'] == 'completed',
                    'action_id': action_id,
                    'final_status': status['status']
                }

            else:
                return {
                    'success': False,
                    'error': f"Unknown action type: {action['type']}"
                }

        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

    async def _wait_for_action_completion(self, action_id: str, timeout: float) -> Dict[str, Any]:
        """Wait for an action to complete with timeout."""
        start_time = time.time()

        while time.time() - start_time < timeout:
            status = await self.action_executor.get_action_status(action_id)

            if status['status'] in ['completed', 'failed', 'cancelled']:
                return status

            await asyncio.sleep(0.1)  # Poll every 100ms

        # Timeout occurred - try to cancel the action
        # This would involve sending a cancel request to the goal handle
        return {
            'status': 'timeout',
            'action_id': action_id
        }
```

## Integration with Task Planning

The action execution system integrates with the task planning system:

```python
class VLAExecutor:
    def __init__(self, action_executor: ActionExecutor, sequence_executor: ActionSequenceExecutor):
        self.action_executor = action_executor
        self.sequence_executor = sequence_executor

    async def execute_task_plan(self, task_plan: TaskPlan) -> Dict[str, Any]:
        """Execute a complete task plan through ROS 2 actions."""
        # Convert task plan to action sequence
        actions = self._convert_tasks_to_actions(task_plan.tasks)

        # Execute the sequence
        sequence_id = await self.sequence_executor.execute_action_sequence(
            task_plan.id,
            actions
        )

        # Monitor execution and provide feedback
        execution_result = await self._monitor_execution(sequence_id)

        return {
            'plan_id': task_plan.id,
            'sequence_id': sequence_id,
            'execution_result': execution_result,
            'completed_at': datetime.now().isoformat()
        }

    def _convert_tasks_to_actions(self, tasks: List[Task]) -> List[Dict[str, Any]]:
        """Convert task plan tasks to executable ROS 2 actions."""
        actions = []

        for task in tasks:
            action = {
                'type': task.type,
                'parameters': task.parameters,
                'timeout': task.timeout,
                'dependencies': task.dependencies
            }
            actions.append(action)

        return actions

    async def _monitor_execution(self, sequence_id: str) -> Dict[str, Any]:
        """Monitor execution and provide feedback to perception system."""
        # This would integrate with the perception system to validate
        # task completion and provide feedback
        while True:
            sequence_info = self.sequence_executor.sequences.get(sequence_id)

            if not sequence_info:
                break

            if sequence_info['status'] in [ActionSequenceStatus.COMPLETED, ActionSequenceStatus.FAILED]:
                break

            # Check for validation opportunities
            await self._validate_current_task(sequence_info)

            await asyncio.sleep(0.5)  # Check every 500ms

        return {
            'status': sequence_info['status'],
            'execution_log': sequence_info['execution_log']
        }

    async def _validate_current_task(self, sequence_info: Dict[str, Any]):
        """Validate the currently executing task using perception feedback."""
        current_index = sequence_info['current_action_index']
        if current_index < len(sequence_info['execution_log']):
            # Trigger perception validation for the completed task
            # This would call the perception validation system
            pass
```

## Error Handling and Recovery

### Action Failure Recovery

```python
class ActionRecoveryManager:
    def __init__(self, action_executor: ActionExecutor):
        self.action_executor = action_executor

    async def handle_action_failure(self, action_id: str, error: str) -> str:
        """Handle action failure and attempt recovery."""
        action_info = self.action_executor.active_actions.get(action_id)

        if not action_info:
            return "action_not_found"

        action_type = action_info['type']

        if action_type == 'navigation' and 'obstacle' in error.lower():
            # Try alternative navigation approach
            return await self._handle_navigation_failure(action_id)
        elif action_type == 'manipulation' and 'collision' in error.lower():
            # Try alternative manipulation approach
            return await self._handle_manipulation_failure(action_id)
        else:
            # General failure handling
            return await self._handle_general_failure(action_id)

    async def _handle_navigation_failure(self, action_id: str) -> str:
        """Handle navigation-specific failures."""
        # Implement navigation recovery strategies
        # - Try alternative path
        # - Request human intervention
        # - Update map with new obstacle information
        return "recovery_attempted"

    async def _handle_manipulation_failure(self, action_id: str) -> str:
        """Handle manipulation-specific failures."""
        # Implement manipulation recovery strategies
        # - Adjust grasp parameters
        # - Retry with different approach angle
        # - Request object repositioning
        return "recovery_attempted"
```

## Performance Optimization

### Concurrency Management

```python
import asyncio
from asyncio import Semaphore

class ConcurrentActionManager:
    def __init__(self, action_executor: ActionExecutor, max_concurrent: int = 3):
        self.action_executor = action_executor
        self.semaphore = Semaphore(max_concurrent)

    async def execute_with_concurrency_limit(self, action_params: Dict[str, Any]):
        """Execute actions with concurrency limits."""
        async with self.semaphore:
            if action_params['type'] == 'navigation':
                return await self.action_executor.execute_navigation_task(action_params)
            elif action_params['type'] == 'manipulation':
                return await self.action_executor.execute_manipulation_task(action_params)
```

## Safety Considerations

### Safety Monitoring

```python
class SafetyMonitor:
    def __init__(self, action_executor: ActionExecutor):
        self.action_executor = action_executor
        self.safety_enabled = True

    async def validate_action_safety(self, action_params: Dict[str, Any]) -> bool:
        """Validate that an action is safe to execute."""
        if not self.safety_enabled:
            return True

        # Check navigation safety
        if action_params['type'] == 'navigation':
            return await self._check_navigation_safety(action_params)

        # Check manipulation safety
        elif action_params['type'] == 'manipulation':
            return await self._check_manipulation_safety(action_params)

        return True

    async def _check_navigation_safety(self, action_params: Dict[str, Any]) -> bool:
        """Check if navigation action is safe."""
        # Verify target location is not in restricted area
        # Check for known obstacles
        # Validate robot state for navigation
        return True

    async def _check_manipulation_safety(self, action_params: Dict[str, Any]) -> bool:
        """Check if manipulation action is safe."""
        # Verify robot joint limits
        # Check for collisions with environment
        # Validate object properties and grasp parameters
        return True
```

## Testing and Validation

### Unit Tests

```python
import unittest
from unittest.mock import Mock, AsyncMock

class TestActionExecutor(unittest.TestCase):
    def setUp(self):
        self.mock_node = Mock()
        self.executor = ActionExecutor()
        # Replace ROS 2 clients with mocks for testing

    async def test_navigation_task_execution(self):
        """Test navigation task execution."""
        params = {'x': 1.0, 'y': 2.0}
        action_id = await self.executor.execute_navigation_task(params)

        self.assertIsNotNone(action_id)
        self.assertIn(action_id, self.executor.active_actions)

    async def test_action_status_query(self):
        """Test action status querying."""
        # Test with valid action ID
        # Test with invalid action ID
        pass
```

### Integration Tests

Test the complete action execution pipeline:
- Task plan to action sequence conversion
- Action execution in simulation environment
- Error handling and recovery
- Safety validation

## Best Practices

### Action Design
- Use appropriate action types for different task categories
- Implement proper timeout and cancellation handling
- Provide meaningful feedback during execution
- Design actions to be idempotent when possible

### Error Handling
- Implement comprehensive error handling at each level
- Provide clear error messages for debugging
- Implement graceful degradation when possible
- Log all errors for system analysis